import random
import matplotlib.pyplot as plt
import copy

class Appliance():
    """
    This class simulates a household appliance. 
    """
    def __init__(self, name, phases):
        self.name = name
        self.phases = phases
        self.ScheduleLength = len(phases)

    def __repr__(self):
        return f"This appliance is a {self.name} and  has a schedule length of {self.ScheduleLength}\n The schedule is {self.phases}"

class Timings():
    """
    This class holds the information about engergy timings
    """
    def __init__(self, costPerPeriod):
        self.costPerPeriod = costPerPeriod # This attribute holds the price of electricity at each period of the day 
        self.length = len(costPerPeriod)

class Solution():
    """
    This class acts as a blueprint for a solution to our problem it includes
        > The schedule of the phases of the solution
        > The cost of the solution
        > The object involved in the solution
        > Multiple ways to generate a solution
    """
    def __init__(self, appliance, timings):
        """
        Following code initalizes a solution generated by randomly shuffling the indexs about
        """
        self.timings = timings
        self.length = timings.length
        self.appliance = appliance
        self.onOff = "Unknown"
        self.findOnOff()
        self.cost = "Unknown"
        self.calculateCost()
        

    def findOnOff(self):
        """
        This method sets the on/off times of the appliance in the solution object.
        """
        onOff = [1 for i in self.appliance.phases] + [0 for i in range(self.timings.length - self.appliance.ScheduleLength)] #Create an array with the energy consupmtion for the appiliance and 0s when its not on
        random.shuffle(onOff)
        self.solutionSchedule = []
        appliancePhaseIndex = 0
        for i in onOff:
            if i == 1:
                self.solutionSchedule.append(self.appliance.phases[appliancePhaseIndex])
                appliancePhaseIndex += 1
            else:
                self.solutionSchedule.append(0)
        self.onOff = onOff

    def calculateCost(self):
        """
        This methoid sets the cost of the solution object.
        """
        total = 0
        for i in range(self.length):
            total += self.solutionSchedule[i] * self.timings.costPerPeriod[i]
        self.cost = total

    def graph(self):
        """
        Following function graphs out the solution nicely.
        """
        xAxis =[i for i in range(self.length)]
        fig, ax = plt.subplots(figsize = (10, 7))
        plt.title("Energy Costs and when to use an Appliance for the lowest cost")
        ax_2 = ax.twinx()
        ax.bar(xAxis, self.solutionSchedule, color = "red", width = 0.5)
        ax_2.plot(xAxis, self.timings.costPerPeriod, color = "blue", linewidth = 5)

        ax.set_xlabel("Time Period")
        ax.set_ylabel("Units Required")
        ax_2.set_ylabel("Cost Per Unit")
        plt.show()

    def __repr__(self):
        return f"This is a solution for the appliance {self.appliance.name}, with timings for use {self.solutionSchedule} which has a cost of {self.cost}"



def open_file(file):
    """
    This function reads a specific problem and returns the approiate Appliance and Timings objects
    """
    with open(file, 'r') as f:
        timingArray = eval(f.readline())
        applianceName = f.readline()
        applianceArray = eval(f.readline())
    return Appliance(applianceName, applianceArray), Timings(timingArray)

def task1(appliance, timing, numberOfRuns):
    """
    
    """
    ListOfCosts = []
    Cheapest = 10000000000
    for i in range(numberOfRuns):
        print("we are ", round(i / numberOfRuns * 100, 2 ), "percent complete")
        tempSolution = Solution(appliance, timing)
        ListOfCosts.append(tempSolution.cost)
        if ListOfCosts[-1] < Cheapest: #checks if this is the new cheapest
            BestSchedules = []
            Cheapest = ListOfCosts[-1] #if it is, replaces the old cheapest number with this
            BestSchedules.append(tempSolution)  #saves the solution to the BestSchedules one
        if (ListOfCosts[-1]) == Cheapest: # if this is as cheap as another soln...
            BestSchedules.append(tempSolution)  # adds the new soln to the BestSchedule part
    ListOfCosts = sorted(ListOfCosts)
    solutions = BestSchedules
    best_cost = min(ListOfCosts)
    return ListOfCosts, solutions, best_cost

def graph_task_1(ListOfCosts):
    """
    Takes the data found in task1 and gives a graph showing the distribution of the random solutions' cost.
    """
    NoDuplicatesListOfCosts = sorted(list(set(ListOfCosts)))
    FrequencyOfCosts = []
    for i in NoDuplicatesListOfCosts:
        FrequencyOfCosts.append(ListOfCosts.count(i))
    plt.xlabel("Cost")
    plt.ylabel("Frequency")
    plt.bar(NoDuplicatesListOfCosts, FrequencyOfCosts, color = 'white')
    plt.plot(NoDuplicatesListOfCosts, FrequencyOfCosts, color = 'grey')
    plt.show()

def testForImprovements(solution):
    """
    Swaps around the schdeule to check for small improvements
    """
    improvedSolutions = []
    givenSchedule = solution.solutionSchedule
    for i in range(solution.length - 1):
        tempSolution = copy.deepcopy(solution)
        if (givenSchedule[i] == 0 and givenSchedule[i+1] != 0):  #Checking if 2 adjectent indexs has one as 0 and the other as a number not 0
            index = copy.copy(i) #copy the index
            while givenSchedule[index] == 0 and index > 0: # Find the next non zero entry in the list
                index -= 1
            if abs(i - index) == 0:
                listOfAllCosts = [solution.timings.costPerPeriod[i]]
            else:
                listOfAllCosts = solution.timings.costPerPeriod[index:i]
            smallestCost = min(listOfAllCosts) #Find the smallest cost from the list of all 0 costs

            indexOfSmallestCost = index + listOfAllCosts.index(smallestCost) #Gets the smallest cost index
            tempSolution.solutionSchedule[i], tempSolution.solutionSchedule[indexOfSmallestCost] = tempSolution.solutionSchedule[indexOfSmallestCost], tempSolution.solutionSchedule[i] #Swaping the indexs

        elif (givenSchedule[i] != 0 and givenSchedule[i+1] == 0): #If there are 0s infront of the number
            index = copy.copy(i) #copy the index
            while givenSchedule[index] == 0 and index < (len(givenSchedule) - 1): # Find the next non zero entry in the list
                index += 1
            if abs(i - index) == 0:
                listOfAllCosts = [solution.timings.costPerPeriod[i]]
            else:
                listOfAllCosts = solution.timings.costPerPeriod[i:index]
            smallestCost = min(listOfAllCosts) #Find the smallest cost from the list of all 0 costs

            indexOfSmallestCost = i + listOfAllCosts.index(smallestCost) #Gets the smallest cost index
        
            tempSolution.solutionSchedule[i], tempSolution.solutionSchedule[indexOfSmallestCost] = tempSolution.solutionSchedule[indexOfSmallestCost], tempSolution.solutionSchedule[i] #Swaping the indexs
        
        tempSolution.calculateCost()
        if tempSolution.cost < solution.cost:
                improvedSolutions.append(tempSolution)
        else:
            del tempSolution
    
    bestCost = 9999999999999999
    for i in improvedSolutions:
        if i.cost < bestCost:
            bestCost = i.cost
    return improvedSolutions , bestCost

def testForImprovements2(solution):
    """
    Prioritising the highest energy cost phase, this function attempts to swap 2 timings of the appliance to give a cheaper result.
    """
    costOfElectricity = solution.timings.costPerPeriod
    appliancePhases = solution.solutionSchedule
    #Finding gaps in appliancePhases
    findingGapsResult = findGaps(appliancePhases, costOfElectricity)
    #Find the best swap
    bestSwap = findBestCostFromSplitArray(findingGapsResult)
    #Copying the solution and making the swap
    newSolution = copy.deepcopy(solution)
    newSolution.solutionSchedule[bestSwap["indexSwap"][0]] , newSolution.solutionSchedule[bestSwap["indexSwap"][1]] = newSolution.solutionSchedule[bestSwap["indexSwap"][1]], newSolution.solutionSchedule[bestSwap["indexSwap"][0]]
    newSolution.calculateCost()
    return newSolution



    #something where we get a sorted list of the phases energy cost and then take [-1] and try moving it to a 0 nearby but if it hits a 1 
    #then the code stops cos we dont want it to swap with a 1 so we can just try moving it within that range and then if it cant move that 
    #one or if the solution doesnt improve the cost then we del that from the list of phases energy costs and then continue that on and on 
    #and it should eventually move everything it can to its cheapest spot so we can get a definite cheapest after doing the random for a 
    #couple million


def findGaps(appliancePhases, electricityPrices):
    """
    This function is how we find gaps and return them as a 2d array 
    """
    nonZeroCount = 0 #Used for tracking how many non 0 entries we pass when we see 2 we push into the dictionary
    result = []
    # Temp dictionary represents 
    tempDictionary = {
        "appliancePhases": [],
        "electricityPrices": [],
        "startIndex": 0,
        "endIndex": 0
    }
    for num, i in enumerate(appliancePhases):
        if num == len(appliancePhases) - 1: #If we are at the end of the list push the temp dictionary to the result
            tempDictionary["appliancePhases"].append(i)
            tempDictionary["electricityPrices"].append(electricityPrices[num])
            tempDictionary["endIndex"] = num
            result.append(tempDictionary)
        elif i != 0 and nonZeroCount == 1: #If we had seen 2 non zero vaules we push the temp dictionary to the result
            tempDictionary["appliancePhases"].append(i)
            tempDictionary["electricityPrices"].append(electricityPrices[num])
            tempDictionary["endIndex"] = num
            result.append(tempDictionary) #Push the dictionary to the result
            #Now we reset the tempDictionary
            tempDictionary = {
                "appliancePhases": [i],
                "electricityPrices": [electricityPrices[num]],
                "startIndex": num,
                "endIndex": 0
            }
        elif i !=0 or (num == 0 and i ==0): #If we see a non 0 or a 0 at the start of the array add the starting index
            tempDictionary["appliancePhases"].append(i)
            tempDictionary["electricityPrices"].append(electricityPrices[num])
            tempDictionary["startIndex"] = num
            nonZeroCount += 1
        else: #else add data to the dictionary
            tempDictionary["appliancePhases"].append(i)
            tempDictionary["electricityPrices"].append(electricityPrices[num])
    return result


def findBestCostFromSplitArray(splitArray):
    """
    This function now finds the best improvement after the arrays have been turned into dictionary from the find costs
    """
    bestChange = {
        "indexSwap": [0, 0],
        "changeInCost": 0
    }
    for i in splitArray:
            possibleSwaps = [i["electricityPrices"][f] for f,x in enumerate(i["appliancePhases"]) if x == 0] #Gets the prices of all the current avalible swaps
            leftSideCurrentCost = i["appliancePhases"][0] * i["electricityPrices"][0]
            rightSideCurrentCost = i["appliancePhases"][-1] * i["electricityPrices"][-1]
            if possibleSwaps != []:
                for num,x in enumerate(possibleSwaps):
                    possilbeCostForPartLeftSide = i["appliancePhases"][0] * x
                    possilbeCostForPartRightSide = i["appliancePhases"][-1] * x
                    if possilbeCostForPartLeftSide < leftSideCurrentCost and (leftSideCurrentCost - possilbeCostForPartLeftSide) > bestChange["changeInCost"]: #Checks the left side to see if there are any better costs
                        bestChange["changeInCost"] = (leftSideCurrentCost - possilbeCostForPartLeftSide)
                        bestChange["indexSwap"] = [i["startIndex"], i["startIndex"] + num + 1]
                    elif possilbeCostForPartRightSide < rightSideCurrentCost and (rightSideCurrentCost - possilbeCostForPartRightSide) > bestChange["changeInCost"]: #Checks the right side for any better costs
                        bestChange["changeInCost"] = (rightSideCurrentCost - possilbeCostForPartRightSide)
                        bestChange["indexSwap"] = [i["endIndex"], i["startIndex"] + num + 1]
    return bestChange

def findBestSolution(solutions):
    bestCost = 9999999999999
    for i in solutions:
        if i.cost < bestCost:
            bestSolution = i
    return bestSolution

def graph_2_different_solutions(solution1, solution2):
    """
    Takes the solutions and graphs them together to compare between.
    """
    xAxis =[i for i in range(solution1.length)]
    
    fig, (ax_1, ax_2) = plt.subplots(1, 2, figsize = (15, 8.1))
    plt.subplots_adjust(left=0.04, right=0.965, bottom=0.06, top=0.9, wspace=0.2, hspace=0.2)

    ax_1b = ax_1.twinx()
    ax_1.bar(xAxis, solution1.solutionSchedule, color = "red", width = 0.5, label = 'Energy Required')
    ax_1b.plot(xAxis, solution1.timings.costPerPeriod, ".-b", linewidth = 3, markersize = 15, label = 'Energy Cost Over Time')
    ax_1.set_title('Energy Costs and when to use an Appliance for the lowest cost')
    ax_1.set_xlabel("Time Period")
    ax_1.set_ylabel("Units Required")
    ax_1b.set_ylabel("Cost Per Unit")

    ax_2b = ax_2.twinx()
    ax_2.bar(xAxis, solution2.solutionSchedule, color = "red", width = 0.5, label = 'Energy Required')
    ax_2b.plot(xAxis, solution2.timings.costPerPeriod, ".-b", linewidth = 3, markersize = 15, label = 'Energy Cost Over Time')
    ax_2.set_title('Energy Costs and when to use an Appliance for the lowest cost')
    ax_2.legend(bbox_to_anchor = (0.06, 1.07))
    ax_2b.legend(bbox_to_anchor = (0.1, 1.12))
    ax_2.set_xlabel("Time Period")
    ax_2.set_ylabel("Units Required")
    ax_2b.set_ylabel("Cost Per Unit")

    plt.show()

def graph_iterations_of_small_improvements(solution, iterations):
    """
    Runs the testForImprovements function a given number of times, each time taking the new best solution
    """
    
    current_best_solution = solution
    costs = [solution.cost]
    for i in range(iterations + 1):
        improved_solution = testForImprovements2(current_best_solution)
        costs.append(improved_solution.cost)
        current_best_solution = improved_solution
    
    plt.xlabel("Number of iterations")
    plt.ylabel("Cost of Schedule")
    plt.plot(costs)
    plt.show()
    return current_best_solution



testAppliance, testTimings = open_file("p3.txt")
costs, schedules, best_cost = task1(testAppliance, testTimings, 100000)

print(best_cost)
graph_task_1(costs)
# print(schedules[0])
# schedules[0].graph()

#The things above this are what we want to print off to complete task 1 so thats sorted.

bestRandomSolution = findBestSolution(schedules)

bestFoundSolution = graph_iterations_of_small_improvements(bestRandomSolution, 50)

graph_2_different_solutions(bestRandomSolution, bestFoundSolution)






